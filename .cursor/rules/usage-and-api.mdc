---
description: Usage instructions, API reference and error handling for json-storage package
globs:
alwaysApply: true
---

# json-storage Usage and API Reference
JSONStorage is a javascript class, that needs to be instantiated first: 
```javascript
    const storage = new JSONStorage({ 
        directory: TEST_DIRECTORY // <- This is path to directory where json docs will be created, updated, deleted etc.
    });
    await storage.connect() // <- Checks access to directory from previous step. Should be called only once per instance.
```

Then, async storage methods can be used to perform CRUD operations on directory:
```javascript
    const { _id, path } = await storage.create('my-data', { name: 'John', age: 21 });
    const fileName = _id; // <- returned _id is used as filename
    const myself = await storage.read(fileName); // <- { name: 'John', age: 21 }
    const updatedMyself = { ...myself, surname: 'Doe' }; // <- old and new data merged
    await storage.update(fileName, updatedMyself);
    // This is just basic example. 
    // It can do many more! delete, all, filter etc.
```

Some CRUD methods can possibly return data ***or throw error if path to file is locked***. This is nodejs error. Json-storage achieves this by creating special *directory* next to file to be processed. 
1. First, method (such as `update`) creates directory with following name format: {filename}.lock by calling fs.mkdir({filename}.lock)
2. Then, it performs operation on actuall file {filename}.json
3. Then it removes directory {filename}.lock. 
4. Meanwhile, if other method tries to process the same file, it first tries to fs.mkdir({filename}.lock) and throws - becasue node.js doesn't allow to create two directories with the same name. This is simple mechanism to prevent concurrent processes on the same file.

json-storage exposes following methods:
- Async method `connect()` checks if directory exists and if current process has access to it. If yes, it awaits for possible other `connect` calls from the same JSONStorage instance to finish - and then, it returns CRUD interface to perform operations on that directory. This method is designed to be used only *once* per instance. Queueing is just for safety reasons, if app *accidentaly* perform more than one connection to given directory. The returned object with API methods contains following methods: create, update, read, delete, all, filter. Those methods are defined as "private", but they are binded in constructor and reassigned to the returned object. Those methods are described below:
1. Async method `create` creates a JSON file from a given data and returns _id and path to file, ***or throws error if path to file is locked***. If *_id* field was not provided, it creates UUID. Then *_id* variable (provided or created) is used as filename. If _id is created, it is not stored in file as a field. If _id was provided, it is stored as a field. 
2. Async method `update` updates content of file (found by fileId as a file name) and returns _id and file path, ***or throws error if path to file is locked*** - also throws ***at _id updation attempt***. File content is overriden by given data - therefore, if any content field should persist, data passed into `update` should be *already merged* with previous data.
3. Async method `read` reads file and returns **JSONStorageDocument** with file content ***or throws error ***.
4. Async method `delete` deletes file with given fileId as fileName and returns void ***or throws error if path to file is locked***
5. Async method `all` returns all json documents in given directory as **JSONStorageDocument** array.
6. Async method `filter` returns all json documents in given directory as **JSONStorageDocument** array, eventually filtered and/or sorted by **Filter** options.

**JSONStorageDocument** file content as javascript object, with _id attached and stats from nodejs fs.stat(path) method. See types/JSONStorage.types.ts
**Filter** mongoDb-like object containing options to perform filtering or sorting records. See types/JSONStorage.types.ts

## Installation
- Use `npm install @bartek01001/json-storage`

## Basic Usage
- Import `JSONStorage` class
- Instantiate with directory option: `new JSONStorage({ directory: './data' })`
- Connect to storage via `await storage.connect()`

## CRUD Operations
- `create(data)`: creates a new JSON document, returns `{ _id, path }`
- `read(fileId)`: reads document by id
- `update(fileId, data)`: updates document
- `delete(fileId)`: deletes document by id
- `all()`: returns all documents as array

## Advanced Filtering
- Use `filter({ where, sort, limit, offset })`
- Filter supports MongoDB-like operators: `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`, `$in`, `$nin`, `$regex`, `$and`, `$or`, `$not`
- Sorting supports fields and order (`asc` or `desc`)
- Pagination via `limit` and `offset`

## Error Handling
- Catch errors on async calls
- Common error codes:
  - `EEXIST`: file already exists
  - `ENOENT`: file not found

## Additional Notes for Cursor
- Follow API method signatures strictly
- Support all listed filter operators when generating queries or code
- Provide examples matching documented usage where relevant
- Refer to `docs/DEVELOPMENT.md` for internal project structure and build workflow
